## Запуск приложения локально

    python3 -m venv venv  # Создание окружения
    source venv/bin/activate  # Активация в Linux/macOS
    venv\Scripts\activate  # Активация в Windows
    pip install --upgrade pip
    pip install -r requirements.txt
    python features.py

## Шаг 1: Реализация отправки данных с уникальными идентификаторами в очереди RabbitMQ

Сначала мы добавим задержку в цикл, генерируем уникальные идентификаторы с использованием datetime.timestamp(), и отправим эти сообщения в очереди RabbitMQ.

В файле features.py:

Для каждого сообщения генерируется уникальный идентификатор message_id, который включает в себя временную метку.
Мы отправляем два сообщения — одно в очередь y_true с истинными значениями, другое в очередь features с векторами признаков. Оба сообщения содержат одинаковые уникальные идентификаторы.
После каждой итерации добавлена задержка time.sleep(10).


## Шаг 2: Логирование метрик в файл metric_log.csv

Для логирования метрик, создадим сервис, который будет обрабатывать сообщения из двух очередей (y_true и features), а затем записывать соответствующие данные в файл CSV.


Cервис metric.py:

Подписывается на две очереди: y_true и features.
Хранит приходящие значения y_true и y_pred в словарях по уникальным идентификаторам.
Когда для одного и того же id приходят и истинные метки, и предсказания, рассчитывает абсолютную ошибку и записывает все данные в файл metric_log.csv.

## Шаг 3: Строим гистограмму абсолютных ошибок

Сервис для построения гистограммы будет работать с данным CSV-файлом и генерировать обновлённую гистограмму в реальном времени.

Cервис plot.py:

Читает данные из файла metric_log.csv каждые 10 секунд.
Строит гистограмму абсолютных ошибок с использованием matplotlib.
Сохраняет график в файл error_distribution.png в папке logs/.

## Шаг 4: Docker и docker-compose
Dockerfile для сервисов

## Шаг 5: Запуск
Соберите контейнеры с помощью команды:

    docker-compose build --no-cache

Запустите сервисы:

    docker-compose up

Теперь ваши сервисы должны работать в режиме реального времени и генерировать графики, которые будут обновляться с каждой итерацией.

